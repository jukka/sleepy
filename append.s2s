'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Copyright 2011 Jukka Zitting <jukka.zitting@gmail.com>                    '
'                                                                           '
' Licensed under the Apache License, Version 2.0 (the "License");           '
' you may not use this file except in compliance with the License.          '
' You may obtain a copy of the License at                                   '
'                                                                           '
'     http://www.apache.org/licenses/LICENSE-2.0                            '
'                                                                           '
' Unless required by applicable law or agreed to in writing, software       '
' distributed under the License is distributed on an "AS IS" BASIS,         '
' WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  '
' See the License for the specific language governing permissions and       '
' limitations under the License.                                            '
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This script asks for a Spike data file and appends all its channels to    '
' those of the currently open data file.                                    '
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var a%, b%, mt;

a% := View();
if ViewKind(a%) <> 0 then
    Message("Please have the data file to be modified already open.");
    halt;
endif;

b% := FileOpen("*.smr", 0, 0, "Select data file to append.");
if b% < 0 then
    Message("Could not open a data file.");
    halt;
endif
if ViewKind(b%) <> 0 then
    View(b%).FileClose();
    Message("Not a data file.");
    halt;
endif

var i%, ch%[100], kind%, st, et, buffer[10000], n%, bs, lt;
View(a%);
ChanList(ch%);
mt := 0.0;
for i% := 1 to ch%[0] do
    if ChanKind(ch%[i%]) = 8 then
        lt := LastTime(ch%[i%], MaxTime(ch%[i%]) + 1);
        if lt > Floor(lt) then
            lt := LastTime(ch%[i%], lt);
        endif
        if lt > mt then
            mt := lt;
        endif
    endif
next
Message("Maxtime %f", mt);
if mt = 0.0 then
    mt := MaxTime();
endif
for i% := 1 to ch%[0] do
    kind% := ChanKind(ch%[i%]);
    bs := BinSize(ch%[i%]);
    if kind% = View(b%).ChanKind(ch%[i%]) and bs = View(b%).BinSize(ch%[i%]) then
        docase
        case kind% = 1 then
            st := 0.0;
            et := View(b%).MaxTime(ch%[i%]);
            repeat
                n% := View(b%).ChanData(ch%[i%], buffer[], st, et, st);
                if n% > 0 then
                    n% := View(a%).ChanWriteWave(ch%[i%], buffer[:n%], mt + st);
                    if n% > 0 then
                        st += n% * bs;
                    endif;
                endif;
            until n% <= 0;
        case kind% = 8 then
            var mc%, code%[4], text$;
            mc% := View(a%).MemChan(0, ch%[i%]); 
            View(a%).MemImport(mc%, ch%[i%], NextTime(ch%[i%], -1), LastTime(ch%[i%], mt));
            st := -1.0;
            repeat
                st := View(b%).NextTime(ch%[i%], st, code%[], text$);
                if st >= 0.0 then
                    View(a%).MemSetItem(mc%, 0, mt + st, code%[], text$);
                endif;
            until st < 0;
            View(a%).MemSave(mc%, ch%[i%]);
            View(a%).ChanDelete(mc%);
            View(a%).DrawMode(ch%[i%], 15, 2);
            View(a%).ChanShow(ch%[i%]);
        endcase;
    endif;
next
View(b%).FileClose();
