'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Copyright 2008 Jukka Zitting <jukka.zitting@gmail.com>                    '
'                                                                           '
' Licensed under the Apache License, Version 2.0 (the "License");           '
' you may not use this file except in compliance with the License.          '
' You may obtain a copy of the License at                                   '
'                                                                           '
'     http://www.apache.org/licenses/LICENSE-2.0                            '
'                                                                           '
' Unless required by applicable law or agreed to in writing, software       '
' distributed under the License is distributed on an "AS IS" BASIS,         '
' WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  '
' See the License for the specific language governing permissions and       '
' limitations under the License.                                            '
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' Constants values for Spike method calls
const NEWCHANNEL%       := 0;      ' ChanNew
const WAVEFORM%         := 1;      ' ChanNew
const DEFAULTBUFFER%    := 0;      ' ChanNew
const PRIMARYCOLOUR%    := 1;      ' ChanColour
const BLACK%            := 1;      ' ChanColour
const RED%              := 16;     ' ChanColour
const SKYLINE%          := 16;     ' DrawMode
const CUSTOMLABEL%      := 4;      ' HCursorLabel
const MEAN%             := 2;      ' ChanMeasure
const OK%               := 1;      ' DlgShow
const MOVERESIZE%       := 0x0004; ' Toolbar
const CANUSEVIEWMENU%   := 0x0020; ' Toolbar
const NOHCURSORCHANNEL% := 0x1000; ' Toolbar
const TEXTFILE%         := 1;      ' FileNew

var emg%;
var epoch;

var epochCount%;
var epochSize%;

var power%;
var score%;

var cursorLow%, cursorHigh%;
var levelLow, levelHigh;

proc CreatePowerChannel()
var data[epochCount%], emgPerEpoch[epochSize%], i%, n%;
power% := ChanNew(NEWCHANNEL%, WAVEFORM%, DEFAULTBUFFER%, epoch);
ChanTitle$(power%, "EMG power");
ChanColour(power%, PRIMARYCOLOUR%, RED%);
ChanWeight(power%, ChanWeight(emg%) / 2.0);
DrawMode(power%, SKYLINE%);
for i% := 0 to epochCount% - 1 do
    n% := ChanData(emg%, emgPerEpoch, i% * epoch, MaxTime(emg%));
    if (n% > 0) then
        data[i%] := ArrDot(emgPerEpoch[:n%], emgPerEpoch[:n%]) * BinSize(emg%);
    else
        data[i%] := 0.0;
    endif;
next;
ChanWriteWave(power%, data, 0.0);
ChanShow(power%);
end;

proc CreatePowerCursors()
cursorLow% := HCursorNew(power%);
HCursorLabel(CUSTOMLABEL%, cursorLow%, "Low active %p");
cursorHigh% := HCursorNew(power%);
HCursorLabel(CUSTOMLABEL%, cursorHigh%, "High active %p");
end;

proc CreateScoreChannel()
score% := ChanNew(NEWCHANNEL%, WAVEFORM%, DEFAULTBUFFER%, epoch);
ChanTitle$(score%, "EMG score");
ChanColour(score%, PRIMARYCOLOUR%, BLACK%);
ChanWeight(score%, ChanWeight(emg%) / 5.0);
DrawMode(score%, SKYLINE%);
YRange(score%, 0.0, 2.0);
ChanShow(score%);
end;

proc UpdateScoreChannel()
var data[epochCount%], i%, n%;
n% := ChanData(power%, data, 0.0, MaxTime(power%));
levelLow := HCursor(cursorLow%);
levelHigh := HCursor(cursorHigh%);
for i% := 0 to epochCount% - 1 do
    docase
    case i% < n% and data[i%] > levelHigh then
        data[i%] := 2.0;
    case i% < n% and data[i%] > levelLow then
        data[i%] := 1.0;
    else
        data[i%] := 0.0;
    endcase;
next;
ChanWriteWave(score%, data, 0.0);
end;

func RefreshScoreIfCursorChanged%()
if levelLow <> HCursor(cursorLow%) or levelHigh <> HCursor(cursorHigh%) then
    UpdateScoreChannel();
endif;
return 1;
end;

proc PrintScoreReport()
var powerData[epochCount%], scoreData[epochCount%], i%, n%, file$;
file$ := FileName$();
if Right$(file$, 4) = ".smr" then
    file$ := Left$(file$, Len(file$) - 4);
endif;
file$ := Print$("%s-emgscore.txt", file$);
n% := ChanData(power%, powerData, 0.0, MaxTime(power%));
n% := ChanData(score%, scoreData, 0.0, MaxTime(score%));
FileNew(TEXTFILE%);
Print("EMG Score\n");
Print("Epoch count\t%d\n", epochCount%);
Print("Epoch length\t%f\n", epoch);
Print("Low acitve\t%f\n", levelLow);
Print("High active\t%f\n", levelHigh);
print("\n");
print("Power\tScore\n");
for i% := 0 to n% - 1 do
    Print("%f\t%1.1f\n", powerData[i%], scoreData[i%]);
next;
FileSaveAs(file$);
FileClose();
end;

' Get the list of visible channels and select an "EMG" channel as the default
var channels%[100];
ChanList(channels%, 0x801);
if channels%[0] > 0 then
    emg% := channels%[1];
    var i%;
    for i% := 2 to channels%[0] do
        if (InStr(ChanTitle$(channels%[i%]), "EMG") > 0) then
            emg% := channels%[i%];
        endif;
    next;
endif;

' Default epoch is five seconds
epoch := 5.0;

DlgCreate("EMG Score Settings");
DlgChan(1, "EMG Channel", channels%);
DlgReal(2, "Epoch (s)", 0.1, 100000.0);
if DlgShow(emg%, epoch) = OK% then
    epochCount% := MaxTime(emg%) / epoch;  ' Total number of epochs
    epochSize% := epoch / BinSize(emg%);   ' Number of data points per epoch
    
    CreatePowerChannel();
    CreatePowerCursors();
    CreateScoreChannel();
    
    ' Set the power cursors to approximate values
    levelLow := ChanMeasure(power%, MEAN%, 0.0, MaxTime(power%)) / 2.0;
    levelHigh := levelLow * 3.0;
    HCursor(cursorLow%, levelLow);
    HCursor(cursorHigh%, levelHigh);
    YRange(power%, 0.0, levelLow * 4.0);
    
    ' Create the score channel    
    UpdateScoreChannel();
    
    var button%;
    ToolbarSet(0, "Refresh", RefreshScoreIfCursorChanged%);
    ToolbarSet(1, "Cancel");
    ToolbarSet(2, "Report");
    button% := Toolbar(
        "Set the score limits by moving the horizontal cursors",
        MOVERESIZE% + CANUSEVIEWMENU% + NOHCURSORCHANNEL%);
    docase
    case button% = 1 then
        Message("Cancel");
    case button% = 2 then
        PrintScoreReport();
    endcase;
    
    ChanDelete(score%);
    HCursorDelete(cursorLow%);
    HCursorDelete(cursorHigh%);
    ChanDelete(power%);
endif;
